// server/server.js
// VERSÃO BASEADA NO DOCUMENTO 05 - CORREÇÃO ESPECÍFICA PARA ÁUDIOS
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const http = require('http');
const socketIO = require('socket.io');
const path = require('path');
const fs = require('fs');
const multer = require('multer');

// CRIAR APP EXPRESS PRIMEIRO
const app = express();
const server = http.createServer(app);
const io = socketIO(server, {
    cors: {
        origin: ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002'],
        methods: ['GET', 'POST'],
        credentials: true
    }
});

// VARIÁVEL GLOBAL DO WHATSAPP SERVICE
let whatsappService = null;

// CONFIGURAÇÃO DO MULTER PARA UPLOAD
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = path.join(__dirname, '../uploads');
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const ext = path.extname(file.originalname);
        const name = path.basename(file.originalname, ext);
        const safeName = name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        cb(null, uniqueSuffix + '-' + safeName + ext);
    }
});

const upload = multer({ 
    storage: storage,
    limits: {
        fileSize: 16 * 1024 * 1024 // 16MB máximo
    },
    fileFilter: function (req, file, cb) {
        const allowedMimes = [
            'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp',
            'video/mp4', 'video/3gpp', 'video/quicktime',
            'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/opus',
            'application/pdf',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ];
        
        if (allowedMimes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error(`Tipo de arquivo não permitido: ${file.mimetype}`));
        }
    }
});

// CRIAR PASTAS NECESSÁRIAS
const createRequiredFolders = () => {
    const folders = [
        path.join(__dirname, '../uploads'),
        path.join(__dirname, '../sessions'),
        path.join(__dirname, '../media'),
        path.join(__dirname, '../logs'),
        path.join(__dirname, '../temp')
    ];
    
    folders.forEach(folder => {
        if (!fs.existsSync(folder)) {
            fs.mkdirSync(folder, { recursive: true });
            console.log(`📁 Pasta criada: ${folder}`);
        }
    });
};

// MIDDLEWARE - CONFIGURAÇÃO BÁSICA
app.use(helmet({
    contentSecurityPolicy: false,
    crossOriginEmbedderPolicy: false
}));

// CORS MUITO PERMISSIVO PARA TESTE
app.use(cors({
    origin: '*',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Range', 'Accept', 'Accept-Ranges'],
    exposedHeaders: ['Content-Range', 'Accept-Ranges', 'Content-Length']
}));

// Rate Limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 1000, // Aumentar limite para teste
    message: 'Muitas requisições, tente novamente mais tarde.'
});
app.use('/api', limiter);

// Body Parser
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// ====================================
// SERVIR ARQUIVOS ESTÁTICOS - VERSÃO HÍBRIDA DO DOCUMENTO 05
// ====================================

// Primeiro, verificar se pasta uploads existe
const uploadsPath = path.join(__dirname, '../uploads');
if (!fs.existsSync(uploadsPath)) {
    fs.mkdirSync(uploadsPath, { recursive: true });
    console.log('📁 Pasta uploads criada:', uploadsPath);
}

// Middleware específico para uploads com Range Requests
app.use('/uploads', (req, res, next) => {
    const filePath = path.join(__dirname, '../uploads', req.path);
    
    console.log('📁 Solicitação de arquivo:', req.path);
    console.log('📍 Caminho completo:', filePath);
    console.log('📊 Headers da requisição:', {
        range: req.headers.range,
        userAgent: req.headers['user-agent']?.substring(0, 50),
        origin: req.headers.origin
    });
    
    // Verificar se arquivo existe
    if (!fs.existsSync(filePath)) {
        console.log('❌ Arquivo não encontrado:', filePath);
        
        // Listar arquivos disponíveis para debug
        try {
            const files = fs.readdirSync(path.join(__dirname, '../uploads'));
            console.log('📂 Arquivos disponíveis:', files.slice(0, 5)); // Primeiros 5
        } catch (e) {
            console.log('❌ Erro ao listar uploads:', e.message);
        }
        
        return res.status(404).json({
            error: 'Arquivo não encontrado',
            requested: req.path,
            fullPath: filePath
        });
    }
    
    const stat = fs.statSync(filePath);
    const fileSize = stat.size;
    const ext = path.extname(filePath).toLowerCase();
    
    // Determinar Content-Type baseado na extensão
    let contentType = 'application/octet-stream';
    if (ext === '.ogg' || ext === '.opus') {
        contentType = 'audio/ogg; codecs=opus';
    } else if (ext === '.mp3') {
        contentType = 'audio/mpeg';
    } else if (ext === '.wav') {
        contentType = 'audio/wav';
    } else if (ext === '.mp4') {
        contentType = 'video/mp4';
    } else if (ext === '.jpg' || ext === '.jpeg') {
        contentType = 'image/jpeg';
    } else if (ext === '.png') {
        contentType = 'image/png';
    } else if (ext === '.pdf') {
        contentType = 'application/pdf';
    }
    
    console.log(`📋 Tipo detectado: ${contentType} para ${ext}`);
    
    // Headers básicos para TODOS os arquivos
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Range, Accept, Accept-Ranges');
    res.setHeader('Access-Control-Expose-Headers', 'Content-Range, Accept-Ranges, Content-Length');
    res.setHeader('Cache-Control', 'public, max-age=3600');
    res.setHeader('Content-Type', contentType);
    res.setHeader('Accept-Ranges', 'bytes');
    
    // Verificar se é Range Request (necessário para áudios)
    const range = req.headers.range;
    
    if (range) {
        console.log(`🎵 Range Request para ${req.path}: ${range}`);
        
        // Parse range header
        const parts = range.replace(/bytes=/, "").split("-");
        const start = parseInt(parts[0], 10);
        const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
        
        if (start >= fileSize) {
            console.log(`❌ Range inválido: start=${start}, fileSize=${fileSize}`);
            res.status(416).send('Range Not Satisfiable');
            return;
        }
        
        const chunksize = (end - start) + 1;
        
        console.log(`📊 Enviando range: ${start}-${end}/${fileSize} (${chunksize} bytes)`);
        
        const stream = fs.createReadStream(filePath, { start, end });
        
        res.writeHead(206, {
            'Content-Range': `bytes ${start}-${end}/${fileSize}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': chunksize,
            'Content-Type': contentType,
            'Access-Control-Allow-Origin': '*'
        });
        
        stream.pipe(res);
    } else {
        console.log(`📄 Enviando arquivo completo: ${req.path} (${fileSize} bytes)`);
        
        res.writeHead(200, {
            'Content-Length': fileSize,
            'Content-Type': contentType,
            'Accept-Ranges': 'bytes',
            'Access-Control-Allow-Origin': '*'
        });
        
        fs.createReadStream(filePath).pipe(res);
    }
});

// Express.static como fallback (caso o middleware acima falhe)
app.use('/uploads', express.static(path.join(__dirname, '../uploads'), {
    setHeaders: (res, path) => {
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Accept-Ranges', 'bytes');
        
        const ext = path.toLowerCase();
        if (ext.endsWith('.ogg') || ext.endsWith('.opus')) {
            res.setHeader('Content-Type', 'audio/ogg; codecs=opus');
        }
    }
}));

// SISTEMA DE LOGS
const logger = {
    info: (message, data = {}) => {
        console.log(`📌 [${new Date().toISOString()}] ${message}`, data);
    },
    success: (message, data = {}) => {
        console.log(`✅ [${new Date().toISOString()}] ${message}`, data);
    },
    warning: (message, data = {}) => {
        console.warn(`⚠️ [${new Date().toISOString()}] ${message}`, data);
    },
    error: (message, error = {}) => {
        console.error(`❌ [${new Date().toISOString()}] ${message}`, error);
    },
    whatsapp: (message, data = {}) => {
        console.log(`💬 [${new Date().toISOString()}] [WhatsApp] ${message}`, data);
    }
};

// ESTADO DO SISTEMA
let systemState = {
    server: {
        status: 'online',
        startedAt: new Date(),
        port: process.env.PORT || 3001
    },
    whatsapp: {
        status: 'disconnected',
        qrCode: null,
        info: null,
        isAuthenticated: false
    },
    stats: {
        messagesReceived: 0,
        messagesSent: 0,
        filesReceived: 0,
        filesSent: 0,
        activeConnections: 0
    }
};

// DADOS MOCK PARA TESTES
const mockUsers = [
    { id: 1, email: 'teste@teste.com', password: '123', name: 'Usuário Teste', role: 'Administrador' },
    { id: 2, email: 'admin@primem.com', password: 'admin123', name: 'Admin', role: 'Administrador' },
    { id: 3, email: 'ana@primem.com', password: '123456', name: 'Ana Costa', role: 'Atendente' },
    { id: 4, email: 'bruno@primem.com', password: '123456', name: 'Bruno Silva', role: 'Atendente' }
];

// ROTAS DA API - SISTEMA

// Health Check
app.get('/api/health', (req, res) => {
    const uploadsDir = path.join(__dirname, '../uploads');
    let uploadCount = 0;
    
    if (fs.existsSync(uploadsDir)) {
        try {
            const files = fs.readdirSync(uploadsDir);
            uploadCount = files.length;
        } catch (e) {
            // Ignorar erro
        }
    }
    
    res.json({
        status: 'ok',
        timestamp: new Date(),
        uptime: process.uptime(),
        uploads: uploadCount,
        uploadsPath: uploadsDir
    });
});

// Status do Sistema
app.get('/api/status', (req, res) => {
    res.json({
        ...systemState,
        hasClient: whatsappService !== null,
        isReady: whatsappService?.isReady || false,
        timestamp: new Date()
    });
});

// Login
app.post('/api/login', (req, res) => {
    const { email, password } = req.body;
    
    const user = mockUsers.find(u => u.email === email && u.password === password);
    
    if (user) {
        const { password, ...userWithoutPassword } = user;
        logger.success(`Login realizado: ${user.name}`);
        res.json({ 
            success: true, 
            user: userWithoutPassword 
        });
    } else {
        logger.warning(`Tentativa de login falhou: ${email}`);
        res.status(401).json({ 
            success: false, 
            message: 'Credenciais inválidas' 
        });
    }
});

// ROTAS DA API - WHATSAPP

// Conectar WhatsApp
app.post('/api/whatsapp/connect', async (req, res) => {
    try {
        if (whatsappService && whatsappService.isReady) {
            return res.json({ 
                success: true, 
                message: 'WhatsApp já está conectado' 
            });
        }
        
        logger.whatsapp('Iniciando conexão WhatsApp...');
        
        if (!whatsappService) {
            try {
                const WhatsAppService = require('./services/whatsapp.service');
                whatsappService = new WhatsAppService(io, logger);
                logger.success('WhatsApp Service carregado');
            } catch (error) {
                logger.error('Erro ao carregar WhatsApp Service:', error);
                return res.status(500).json({
                    success: false,
                    message: 'WhatsApp Service não encontrado'
                });
            }
        }
        
        whatsappService.initialize().catch(error => {
            logger.error('Erro na inicialização do WhatsApp:', error);
            systemState.whatsapp.status = 'error';
            systemState.whatsapp.error = error.message;
        });
        
        systemState.whatsapp.status = 'connecting';
        
        res.json({ 
            success: true, 
            message: 'Iniciando conexão. Aguarde o QR Code.' 
        });
    } catch (error) {
        logger.error('Erro ao conectar WhatsApp:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message 
        });
    }
});

// Desconectar WhatsApp
app.post('/api/whatsapp/disconnect', async (req, res) => {
    try {
        if (whatsappService) {
            await whatsappService.disconnect();
            whatsappService = null;
        }
        
        systemState.whatsapp = {
            status: 'disconnected',
            qrCode: null,
            isAuthenticated: false,
            info: null
        };
        
        io.emit('whatsapp:disconnected');
        logger.whatsapp('WhatsApp desconectado');
        
        res.json({ 
            success: true, 
            message: 'WhatsApp desconectado' 
        });
    } catch (error) {
        logger.error('Erro ao desconectar:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message 
        });
    }
});

// Obter lista de chats
app.get('/api/whatsapp/chats', async (req, res) => {
    try {
        if (!whatsappService || !whatsappService.isReady) {
            return res.json({ 
                success: false, 
                message: 'WhatsApp não está conectado',
                chats: [] 
            });
        }
        
        const chats = await whatsappService.getChats();
        
        res.json({ 
            success: true, 
            chats: chats 
        });
    } catch (error) {
        logger.error('Erro ao obter chats:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message,
            chats: [] 
        });
    }
});

// Enviar mensagem
app.post('/api/whatsapp/send', async (req, res) => {
    try {
        const { to, message } = req.body;
        const number = to || req.body.number;
        
        if (!number || !message) {
            return res.status(400).json({ 
                success: false, 
                message: 'Número e mensagem são obrigatórios' 
            });
        }
        
        if (!whatsappService || !whatsappService.isReady) {
            return res.status(400).json({ 
                success: false, 
                message: 'WhatsApp não está conectado' 
            });
        }
        
        logger.info(`📨 Enviando mensagem para ${number}`);
        
        const result = await whatsappService.sendMessage(number, message);
        
        systemState.stats.messagesSent++;
        
        res.json({ 
            success: true, 
            message: 'Mensagem enviada',
            messageId: result.messageId 
        });
    } catch (error) {
        logger.error('Erro ao enviar mensagem:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message 
        });
    }
});

// Enviar arquivo/mídia
app.post('/api/whatsapp/send-media', upload.single('file'), async (req, res) => {
    try {
        const { to, caption } = req.body;
        const number = to || req.body.number;
        const file = req.file;
        
        logger.info('📎 Requisição de envio de mídia recebida');
        
        if (!number || !file) {
            if (file && fs.existsSync(file.path)) {
                fs.unlinkSync(file.path);
            }
            return res.status(400).json({ 
                success: false, 
                message: 'Número e arquivo são obrigatórios' 
            });
        }
        
        if (!whatsappService || !whatsappService.isReady) {
            if (file && fs.existsSync(file.path)) {
                fs.unlinkSync(file.path);
            }
            return res.status(400).json({ 
                success: false, 
                message: 'WhatsApp não está conectado' 
            });
        }
        
        logger.info(`📎 Enviando arquivo: ${file.filename} para ${number}`);
        
        const result = await whatsappService.sendMessage(
            number, 
            caption || '', 
            file.path
        );
        
        systemState.stats.filesSent++;
        
        // Agendar deleção do arquivo após 1 hora
        setTimeout(() => {
            if (fs.existsSync(file.path)) {
                fs.unlinkSync(file.path);
                logger.info(`🗑️ Arquivo temporário removido: ${file.filename}`);
            }
        }, 3600000);
        
        logger.success(`✅ Arquivo enviado: ${file.filename}`);
        
        res.json({ 
            success: true, 
            message: 'Arquivo enviado com sucesso',
            messageId: result.messageId,
            file: {
                filename: file.filename,
                originalName: file.originalname,
                size: file.size,
                mimetype: file.mimetype,
                url: `/uploads/${file.filename}`
            }
        });
    } catch (error) {
        logger.error('❌ Erro ao enviar arquivo:', error);
        
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }
        
        res.status(500).json({ 
            success: false, 
            message: error.message 
        });
    }
});

// Obter mensagens
app.get('/api/whatsapp/messages/:chatId', async (req, res) => {
    try {
        const { chatId } = req.params;
        
        if (!whatsappService || !whatsappService.isReady) {
            return res.json({ 
                success: false, 
                message: 'WhatsApp não está conectado',
                messages: [] 
            });
        }
        
        const messages = await whatsappService.getChatMessages(chatId);
        
        res.json({ 
            success: true, 
            messages: messages 
        });
    } catch (error) {
        logger.error('Erro ao obter mensagens:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message,
            messages: [] 
        });
    }
});

// ROTA DE DEBUG - LISTAR UPLOADS
app.get('/debug/uploads', (req, res) => {
    const uploadsDir = path.join(__dirname, '../uploads');
    
    if (!fs.existsSync(uploadsDir)) {
        return res.json({ 
            error: 'Pasta uploads não existe',
            path: uploadsDir 
        });
    }
    
    try {
        const files = fs.readdirSync(uploadsDir).map(file => {
            const filePath = path.join(uploadsDir, file);
            const stat = fs.statSync(filePath);
            return {
                name: file,
                size: stat.size,
                modified: stat.mtime,
                url: `/uploads/${file}`
            };
        });
        
        res.json({
            uploadsPath: uploadsDir,
            totalFiles: files.length,
            files: files,
            testUrls: files.slice(0, 3).map(f => `http://localhost:3001${f.url}`)
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// WEBSOCKET - CONEXÕES
io.on('connection', (socket) => {
    systemState.stats.activeConnections++;
    logger.info(`Cliente conectado: ${socket.id}`);
    
    socket.emit('system:state', systemState);
    
    if (whatsappService && whatsappService.isReady) {
        socket.emit('whatsapp:ready', { 
            connected: true,
            timestamp: new Date() 
        });
    }
    
    socket.on('ping', () => {
        socket.emit('pong', { timestamp: Date.now() });
    });
    
    socket.on('disconnect', () => {
        systemState.stats.activeConnections--;
        logger.info(`Cliente desconectado: ${socket.id}`);
    });
});

// TRATAMENTO DE ERROS
app.use((err, req, res, next) => {
    logger.error('Erro na aplicação:', err);
    res.status(500).json({
        success: false,
        message: 'Erro interno do servidor'
    });
});

// 404 Handler
app.use((req, res) => {
    logger.warning(`404 - Rota não encontrada: ${req.method} ${req.url}`);
    res.status(404).json({
        success: false,
        message: 'Rota não encontrada'
    });
});

// INICIALIZAÇÃO
const PORT = process.env.PORT || 3001;

const startServer = async () => {
    try {
        createRequiredFolders();
        
        server.listen(PORT, () => {
            logger.success('=================================');
            logger.success(`🚀 PRIMEM WHATSAPP v5.1 - ÁUDIO CORRIGIDO`);
            logger.success('=================================');
            logger.info(`🔡 Servidor rodando na porta ${PORT}`);
            logger.info(`🌐 URL: http://localhost:${PORT}`);
            logger.success('=================================');
            logger.info('🎵 Sistema de áudios HABILITADO');
            logger.info('📁 Uploads: /uploads/*');
            logger.info('🔍 Debug: /debug/uploads');
            logger.success('=================================');
        });
    } catch (error) {
        logger.error('❌ Erro ao iniciar servidor:', error);
        process.exit(1);
    }
};

startServer();

module.exports = { app, server, io, logger, systemState };